/**
 * This library provides means for representing values that may or may not
 * exist. This can come handy for representing optional arguments,
 * error handling, and records with optional fields.
 */
/**
 * Type representing absence of value. Library treats all of the typescript
 * primitives for absense of value as `Nothing`.
 */
export declare type Nothing = void | null | undefined;
/**
 * Type reprsenting some value. Library treats arbitrary value other than
 * `Nothing` as `Just` that value.
 */
export declare type Just<a> = a;
/**
 * Type represent value that may not exist in which case it's `Nothing` or
 * `Just` that value.
 */
export declare type Maybe<a> = Nothing | Just<a>;
/**
 * Turns arbitrary value into maybe value.
 * @param value arbitrary value
 */
export declare const just: <a>(value: a) => Maybe<a>;
/**
 * Just provides an alias to `null`.
 */
export declare const nothing: Maybe<any>;
/**
 * Provide a `fallback` value, turning an optional value into a normal value.
 *
 * ```ts
 * Maybe.toValue(5, Maybe.just(9)) // => Maybe.just(9)
 * Maybe.toValue(6, Maybe.nothing) // => Maybe.just(6)
 * ```
 * @param fallback Fallback value
 * @param maybe Optional value
 */
export declare const toValue: <a>(fallback: a, maybe: Maybe<a>) => a;
/**
 * Transform a Maybe value with a given function:
 *
 * ```ts
 * Maybe.map(Math.sqrt, Maybe.just(9)) // => Maybe.just(3)
 * Maybe.map(Math.sqrt, Maybe.nothing) // => Maybe.nothing
 * ```
 * @param f Function that maps underlayng value.
 * @param maybe Maybe value to be transformed.
 */
export declare const map: <a, b>(f: (input: a) => b, maybe: Maybe<a>) => Maybe<b>;
/**
 * Utility to chain together two computations that may fail (return Nothing).
 *
 * ```ts
 * const makeGreeting = (name:string):string =>
 *  `Hello ${name}!`
 *
 * const greet = (name:Maybe<string>):Maybe<string> =>
 *  Maybe.chain(makeGreeting, name)
 *
 * greet(Maybe.nothing) // => Maybe.nothing
 * greet(Maybe.just('world')) // => Maybe.just('Hello world!')
 * ```
 *
 * @param then Function that performs second computation from the a result of
 * the first one (if it was successful - returned Just).
 * @param maybe Maybe value, representing result of first computation.
 */
export declare const chain: <a, b>(then: (input: a) => Maybe<b>, maybe: Maybe<a>) => Maybe<b>;
/**
 * Returns `Nothing` if the left Maybe is `Nothing`, otherwise returns the
 * right Maybe.
 *
 * ```ts
 * Maybe.and(Maybe.just(2), Maybe.nothing) // => Maybe.nothing
 * Maybe.and(Maybe.nothing, Maybe.just('foo')) // => Maybe.nothing
 * Maybe.and(Maybe.just(2), Maybe.just('foo')) // => Maybe.just('foo')
 * Maybe.and(Maybe.nothing, Maybe.nothing) // => Maybe.nothing
 * ```
 */
export declare const and: <a, b>(left: Maybe<a>, right: Maybe<b>) => Maybe<b>;
/**
 * Returns the left Maybe if it is a Just value, otherwise returns right Maybe.
 *
 * ```js
 * Maybe.or(Maybe.just(2), Maybe.nothing) // => Maybe.just(2)
 * Maybe.or(Maybe.nothing, Maybe.just('foo')) // => Maybe.just('foo')
 * Maybe.or(Maybe.just(2), Maybe.just(100)) // => Maybe.just(2)
 * Maybe.or(Maybe.nothing, Maybe.nothing) // => Maybe.nothing
 * ```
 */
export declare const or: <a>(left: Maybe<a>, right: Maybe<a>) => Maybe<a>;
/**
 * Predicate that refines given Maybe. If returns `true` given `Maybe` is
 * refined to `Just`, otherwise refined to `Nothing`.
 *
 * ```ts
 * const name:Maybe<string> = Maybe.nothing
 * if (isJust(name)) {
 *   console.log(name.toLowerCase())
 * }
 * ```
 */
export declare const isJust: <a>(maybe: Maybe<a>) => maybe is a;
/**
 * Predicate that refines given Maybe. If returns `true` given `Maybe` is
 * refined to `Nothing`, otherwise refined to `Just`.
 *
 * ```ts
 * const name:Maybe<string> = Maybe.nothing
 * if (!isNothing(name)) {
 *   console.log(name.toLowerCase())
 * }
 * ```
 */
export declare const isNothing: <a>(maybe: Maybe<a>) => maybe is Nothing;

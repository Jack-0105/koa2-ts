"use strict";
/**
 * Library provides APIs to work with a dictionary mapping of unique string
 * keys to values.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Dictionary class used across the library to create `Dict` instances.
 */
exports.Dictionary = function Dictionary() { };
exports.Dictionary.prototype = Object.freeze(Object.create(null));
function empty(_) {
    return new exports.Dictionary();
}
exports.empty = empty;
/**
 * Create a dictionary with one entry of given key, value pair.
 *
 * ```ts
 * Dictionary.singleton('Zoe', 15) // => <Dict<number>>{Zoe: 15}
 * Dictionary.singleton('a', {foo:"bar"}) // => <Dict<{foo:string}>>{a: {foo:"bar"}}
 * ```
 */
exports.singleton = (key, value) => {
    const result = empty();
    result[key] = value;
    return result;
};
/**
 * Convert an iterable of `[key, value]` pairs into a dictionary.
 *
 * ```ts
 * Dictionary.fromEntries([
 *    ['Zoe', 17],
 *    ['Sandro', 18]
 * ]) // => <Dict<number>> {Zoe: 17, Sandro: 18}
 *
 * Dictionary
 *  .fromEntries((<Map<string, User>>db).entries()) // => <Dict<User>>
 * ```
 */
exports.fromEntries = (entries) => {
    const result = empty();
    for (let [key, value] of entries) {
        result[key] = value;
    }
    return result;
};
/**
 * Insert an entry under the given key with a gievn value into a dictionary.
 * Replaces value of the entry if there was one under that key.
 *
 * ```ts
 * const v0 = Dictionary.fromEntries([["a", 1]])
 * v0 // => <Dict<number>> {a:1}
 *
 * // Add
 * const v1 = Dictionary.set("b", 2, v0)
 * v1 // => <Dict<number>> {a:1, b:2}
 *
 * // Replace
 * const v2 = Dictionary.set("b", 15, v1)
 * v2 // => <Dict<number>> {a:1, b:15}
 * ```
 */
exports.set = (key, value, dict) => (dict[key] = value, dict);
/**
 * Updates the entry in the dictionary for a given key with a provided
 * `updater` function. If updader returns `Maybe.nothing` entry is
 * removed from the dictionory otherwise it's value is swapped with
 * returned value.
 *
 * ```ts
 * const v0 = Dictionary.fromEntries([["a", 1], ["b", 2]])
 * v0 // => <Dict<number>>{a:1, b:2}
 *
 * const inc = (v:null|undefined|number):number =>
 *    v == null ? 0 : v + 1
 *
 * // Add
 * const v1 = Dictionary.update("c", inc, v0)
 * v1 // => <Dict<number>>{a:1, b:2, c:0}
 *
 * // Modify
 * const v2 = Dictionary.update("b", inc, v1)
 * v2 // => <Dict<number>>{a:1, b:3, c:0}
 *
 * // Delete
 * const v3 = Dictionary.update("b", _ => null, v2)
 * v3 // => <Dict<number>>{a:1, c:0}
 *
 * const v4 = Dictionary.update("c", _ => undefined, v3)
 * v4 // => <Dict<number>>{a:1}
 *
 * // NoOp
 * const v5 = Dictionary.update("d", _ => null, v4)
 * v5 // => <Dict<number>>{a: 1}
 * ```
 */
exports.update = (key, updater, dict) => {
    const value = updater(dict[key]);
    if (value == null) {
        delete dict[key];
        return dict;
    }
    else {
        dict[key] = value;
        return dict;
    }
};
/**
 * Remove an entry for the given key from a dictionary. If there is no entry
 * for the given key no changes are made.
 *
 * ```ts
 * const before = Dictionary.fromEntries([["a", 1], ["b", 2]])
 * before // => <Dict<number>>{a: 1, b:2}
 * const after = Dictionary.remove("a", before)
 * after // => <Dict<number>>{b:2}
 * Diremove("c", after) // => <Dict<number>>{b:2}
 * ```
 */
exports.remove = (key, dict) => (delete dict[key], dict);
/**
 * Determine if there is an entry with a given key is in a dictionary.
 *
 * ```
 * const dict = Dictionary.singleton("a", 1)
 *
 * Dictionary.has("a", dict) // => true
 * Dictionary.has("b", dict) // => false
 * ```
 */
exports.has = (key, dict) => key in dict;
/**
 * Get the value of the entry with a given key and fallback in case if there is
 * no such entry.
 *
 * ```ts
 * const animals = Dictionary.fromEntries([["Tom", "Cat"], ["Jerry", "Mouse"]])
 *
 * Dictionary.get("Tom", animals, null) => <string|null> "Cat"
 * Dictionary.get("Tom", animals, "") => <string> "Cat"
 * Dictionary.get("Spike", animals, null) => <string|null> null
 * Dictionary.get("Spike", animals, "") => <string> ""
 * ```
 */
exports.get = (key, dict, fallback) => key in dict ? dict[key] : fallback;
/**
 * Returns an iterable of dictionary [key, value] pairs using `for of`
 *
 * ```ts
 * const dict = Dictionary.singleton('Car', {color:'blue'})
 *
 * for (let [key, value] of Dictionary.entries(dict)) {
 *    // ...
 * }
 * ```
 */
function* entries(dict) {
    for (let key in dict) {
        yield [key, dict[key]];
    }
}
exports.entries = entries;
/**
 * Returns an iterable of dictionary keys using `for of`
 *
 * ```ts
 * const dict = Dictionary.singleton('Bicycle', {color:'red'})
 *
 * for (let key of Dictionary.keys(dict)) {
 *    // ...
 * }
 * ```
 */
function* keys(dict) {
    for (let key in dict) {
        yield key;
    }
}
exports.keys = keys;
/**
 * Returns an iterable of dictionary values using `for of`
 *
 * ```ts
 * const dict = Dictionary.singleton('Horse', {color:'black'})
 *
 * for (let value of Dictionary.values(dict)) {
 *    // ...
 * }
 * ```
 */
function* values(dict) {
    for (let key in dict) {
        yield dict[key];
    }
}
exports.values = values;
/**
 * Creates new dictionary with entries from given dictionary but with it's
 * values mapped via given `f` function.
 *
 * ```ts
 * const before = Dictionary.fromEntries([["a", 1], ["b", 2]])
 * before // => <Dict<number>>{a: 1, b: 2}
 *
 * const after = Dictionary.map(([k, v]) =>
 *                               [k.toUpperCase(), String(v + 5)], before)
 * after // => <Dict<string>>{A:"6", B:"7"}
 * ```
 */
exports.map = (f, dict) => {
    const mapped = empty();
    for (let key in dict) {
        const [newKey, newValue] = f([key, dict[key]]);
        mapped[newKey] = newValue;
    }
    return mapped;
};
/**
 * Keep a dictionary entries when it satisfies a predicate.
 *
 * ```ts
 * const before = Dictionary.fromEntries([["a", -1], ["b", 2]])
 * before // => <Dict<number>>{a: -1, b: 2}
 *
 * const after = Dictionary.filter(([_k, v]) => v > 0, before)
 * after // => <Dict<number>>{b: 2}
 * ```
 */
exports.filter = (p, dict) => {
    const filtered = empty(dict);
    for (let key in dict) {
        const value = dict[key];
        if (p([key, value])) {
            filtered[key] = value;
        }
    }
    return filtered;
};
/**
 * Partition a dictionary according to a predicate. The first dictionary
 * contains all entries which satisfy the predicate, and the second contains
 * the rest.
 *
 * ```ts
 * const all = Dictionary.fromEntries([["a", -1], ["b", 2]])
 * all // => <Dict<number>>{a: -1, b: 2}
 *
 * const [positive, negative] = Dictionary.partition(([_k, v]) => v > 0, all)
 * positive // => <Dict<number>>{b: 2}
 * negative // => <Dict<number>>{a: -1}
 * ```
 */
exports.partition = (p, dict) => {
    const filtered = empty(dict);
    const rest = empty(dict);
    for (let key in dict) {
        const value = dict[key];
        if (p([key, value])) {
            filtered[key] = value;
        }
        else {
            rest[key] = value;
        }
    }
    return [filtered, rest];
};
/**
 * Combine two dictionaries. If there is a collision, preference is given to
 * the first dictionary.
 *
 * ```ts
 * const left = Dictionary.fromEntries([["a", 1], ["b", 2]])
 * left // => <Dict<number>>{a:1, b:2}
 *
 * const right = Dictionary.fromEntries([["b", 18], ["c", 9]])
 * right // => <Dict<number>>{b:18, c:9}
 *
 * const union = Dictionary.union(left, right)
 * union // => <Dict<number>>{a:1, b:2, c:9}
 * ```
 */
exports.union = (left, right) => {
    const union = empty(left);
    for (let key in left) {
        union[key] = left[key];
    }
    for (let key in right) {
        if (!(key in union)) {
            union[key] = right[key];
        }
    }
    return union;
};
/**
 * Keep a entries from left dictionary when right dictionary has entries for
 * the same key.
 *
 * ```ts
 * const left = Dictionary.fromEntries([["a", 1], ["b", 2]])
 * left // => <Dict<number>>{a:1, b:2}
 *
 * const right = Dictionary.fromEntries([["b", 18], ["c", 9]])
 * right // => <Dict<number>>{b:18, c:9}
 *
 * const intersect = Dictionary.intersect(left, right)
 * intersect // => <Dict<number>>{b:2}
 * ```
 */
exports.intersect = (left, right) => {
    const intersect = empty(left);
    for (let key in left) {
        if (key in right) {
            intersect[key] = left[key];
        }
    }
    return intersect;
};
/**
 * Keep a entries from left dictionary only if right dictionary does not have
 * entry for that key.
 *
 * ```ts
 * const left = Dictionary.fromEntries([["a", 1], ["b", 2]])
 * left // => <Dict<number>>{a:1, b:2}
 * const right = Dictionary.fromEntries([["b", 18], ["c", 9]])
 * right // => <Dict<number>>{b:18, c:9}
 * const diff = Dictionary.diff(left, right)
 * diff // => <Dict<number>>{a:1}
 * ```
 */
exports.diff = (left, right) => {
    const result = empty(left);
    for (let key in left) {
        if (!(key in right)) {
            result[key] = left[key];
        }
    }
    return result;
};
/**
 *  The most general way of combining two dictionaries. You provide three
 * accumulators for when a given key appears:
 *
 * - Only in the left dictionary.
 * - In both dictionaries.
 * - Only in the right dictionary.
 *
 * You then traverse all the keys from lowest to highest, building up whatever
 * you want.
 *
 * ```ts
 * Dictionary.merge(
 *   ([key, left], log) =>
 *      [...log, `- ${key} : ${left}`],
 *   ([key, [left, right]], log) =>
 *      [...log, `= ${key} : ${left} -> ${right}`],
 *   ([key, right], log) =>
 *      [...log, `+ ${key} : ${right}`],
 *   Dictionary.fromEntries([["a", 1], ["b", 2]]),
 *   Dictionary.fromEntries([["b", 18], ["c", 9]]),
 *   <string[]>[]) // => ['- a : 1', '= b : 2 -> 18', '+ c : 9']
 * ```
 */
exports.merge = (accumulateLeft, accumulateBoth, accumulateRight, left, right, init) => {
    let state = init;
    for (let key in left) {
        const leftValue = left[key];
        if (key in right) {
            const rightValue = right[key];
            state = accumulateBoth([key, [leftValue, rightValue]], state);
        }
        else {
            state = accumulateLeft([key, leftValue], state);
        }
    }
    for (let key in right) {
        const rightValue = right[key];
        if (!(key in left)) {
            state = accumulateRight([key, rightValue], state);
        }
    }
    return state;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGljdGlvbmFyeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInNyYy9EaWN0aW9uYXJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7O0FBZUg7O0dBRUc7QUFDVSxRQUFBLFVBQVUsR0FBMEIsd0JBQTRCLENBQUMsQ0FBQTtBQUM5RSxrQkFBVSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtBQXdDekQsZUFBMkIsQ0FBVTtJQUNuQyxNQUFNLENBQUMsSUFBSSxrQkFBVSxFQUFFLENBQUE7QUFDekIsQ0FBQztBQUZELHNCQUVDO0FBR0Q7Ozs7Ozs7R0FPRztBQUNVLFFBQUEsU0FBUyxHQUFHLENBQUssR0FBVSxFQUFFLEtBQU87SUFDL0MsTUFBTSxNQUFNLEdBQUcsS0FBSyxFQUFFLENBQUE7SUFDdEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQTtJQUNuQixNQUFNLENBQUMsTUFBTSxDQUFBO0FBQ2YsQ0FBQyxDQUFBO0FBRUQ7Ozs7Ozs7Ozs7OztHQVlHO0FBQ1UsUUFBQSxXQUFXLEdBQUcsQ0FBSyxPQUEwQjtJQUN4RCxNQUFNLE1BQU0sR0FBRyxLQUFLLEVBQUUsQ0FBQTtJQUN0QixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDakMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQTtJQUNyQixDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQTtBQUNmLENBQUMsQ0FBQTtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ1UsUUFBQSxHQUFHLEdBQ2QsQ0FBSyxHQUFVLEVBQUUsS0FBTyxFQUFFLElBQVksS0FDdEMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFB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